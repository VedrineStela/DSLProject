/*
 * generated by Xtext 2.25.0
 */
package fr.univcotedazur.l3ia.program.serializer;

import com.google.inject.Inject;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Accelerate;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Addition;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Assignment;
import fr.univcotedazur.l3ia.Tp_03_02_2022.ColorRef;
import fr.univcotedazur.l3ia.Tp_03_02_2022.ColorSensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Comparison;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Division;
import fr.univcotedazur.l3ia.Tp_03_02_2022.ElseMotor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Equal;
import fr.univcotedazur.l3ia.Tp_03_02_2022.EqualM;
import fr.univcotedazur.l3ia.Tp_03_02_2022.ForLoop;
import fr.univcotedazur.l3ia.Tp_03_02_2022.GPSSensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.GreaterThan;
import fr.univcotedazur.l3ia.Tp_03_02_2022.GreatherThanM;
import fr.univcotedazur.l3ia.Tp_03_02_2022.GyroSensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.IfCondition;
import fr.univcotedazur.l3ia.Tp_03_02_2022.IfMotor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.InfraredSensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.IntensitySensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.LeftMotor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.LeftRotation;
import fr.univcotedazur.l3ia.Tp_03_02_2022.LightSensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.LowerThan;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Move;
import fr.univcotedazur.l3ia.Tp_03_02_2022.MoveLeft;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Multiplication;
import fr.univcotedazur.l3ia.Tp_03_02_2022.OnForRotation;
import fr.univcotedazur.l3ia.Tp_03_02_2022.PositionSensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Program;
import fr.univcotedazur.l3ia.Tp_03_02_2022.ReferenceToColor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.RightMotor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.RightRotation;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Robot;
import fr.univcotedazur.l3ia.Tp_03_02_2022.SetThank;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Statement;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Stop;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Substraction;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Tp_03_02_2022Package;
import fr.univcotedazur.l3ia.Tp_03_02_2022.TurnOn;
import fr.univcotedazur.l3ia.Tp_03_02_2022.UltrasonicSensor;
import fr.univcotedazur.l3ia.Tp_03_02_2022.Variable;
import fr.univcotedazur.l3ia.Tp_03_02_2022.VariableRef;
import fr.univcotedazur.l3ia.Tp_03_02_2022.WhileLoop;
import fr.univcotedazur.l3ia.program.services.ProgGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ProgSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ProgGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Tp_03_02_2022Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Tp_03_02_2022Package.ACCELERATE:
				sequence_Accelerate(context, (Accelerate) semanticObject); 
				return; 
			case Tp_03_02_2022Package.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case Tp_03_02_2022Package.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case Tp_03_02_2022Package.COLOR_REF:
				sequence_ColorRef(context, (ColorRef) semanticObject); 
				return; 
			case Tp_03_02_2022Package.COLOR_SENSOR:
				sequence_ColorSensor(context, (ColorSensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.COMPARISON:
				sequence_Comparison_Impl(context, (Comparison) semanticObject); 
				return; 
			case Tp_03_02_2022Package.DIVISION:
				sequence_Division(context, (Division) semanticObject); 
				return; 
			case Tp_03_02_2022Package.ELSE_MOTOR:
				sequence_ElseMotor(context, (ElseMotor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case Tp_03_02_2022Package.EQUAL_M:
				sequence_EqualM(context, (EqualM) semanticObject); 
				return; 
			case Tp_03_02_2022Package.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case Tp_03_02_2022Package.GPS_SENSOR:
				sequence_GPSSensor(context, (GPSSensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.GREATER_THAN:
				sequence_GreaterThan(context, (GreaterThan) semanticObject); 
				return; 
			case Tp_03_02_2022Package.GREATHER_THAN_M:
				sequence_GreatherThanM(context, (GreatherThanM) semanticObject); 
				return; 
			case Tp_03_02_2022Package.GYRO_SENSOR:
				sequence_GyroSensor(context, (GyroSensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.IF_CONDITION:
				sequence_IfCondition(context, (IfCondition) semanticObject); 
				return; 
			case Tp_03_02_2022Package.IF_MOTOR:
				sequence_IfMotor(context, (IfMotor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.INFRARED_SENSOR:
				sequence_InfraredSensor(context, (InfraredSensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.INTENSITY_SENSOR:
				sequence_IntensitySensor(context, (IntensitySensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.LEFT_MOTOR:
				sequence_LeftMotor(context, (LeftMotor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.LEFT_ROTATION:
				sequence_LeftRotation(context, (LeftRotation) semanticObject); 
				return; 
			case Tp_03_02_2022Package.LIGHT_SENSOR:
				sequence_LightSensor(context, (LightSensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.LOWER_THAN:
				sequence_LowerThan(context, (LowerThan) semanticObject); 
				return; 
			case Tp_03_02_2022Package.MOVE:
				sequence_Move(context, (Move) semanticObject); 
				return; 
			case Tp_03_02_2022Package.MOVE_LEFT:
				sequence_MoveLeft(context, (MoveLeft) semanticObject); 
				return; 
			case Tp_03_02_2022Package.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case Tp_03_02_2022Package.ON_FOR_ROTATION:
				sequence_OnForRotation(context, (OnForRotation) semanticObject); 
				return; 
			case Tp_03_02_2022Package.POSITION_SENSOR:
				sequence_PositionSensor(context, (PositionSensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case Tp_03_02_2022Package.REFERENCE_TO_COLOR:
				sequence_ReferenceToColor(context, (ReferenceToColor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.RIGHT_MOTOR:
				sequence_RightMotor(context, (RightMotor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.RIGHT_ROTATION:
				sequence_RightRotation(context, (RightRotation) semanticObject); 
				return; 
			case Tp_03_02_2022Package.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case Tp_03_02_2022Package.SET_THANK:
				sequence_SetThank(context, (SetThank) semanticObject); 
				return; 
			case Tp_03_02_2022Package.STATEMENT:
				sequence_Statement_Impl(context, (Statement) semanticObject); 
				return; 
			case Tp_03_02_2022Package.STOP:
				sequence_Stop(context, (Stop) semanticObject); 
				return; 
			case Tp_03_02_2022Package.SUBSTRACTION:
				sequence_Substraction(context, (Substraction) semanticObject); 
				return; 
			case Tp_03_02_2022Package.TURN_ON:
				sequence_TurnOn(context, (TurnOn) semanticObject); 
				return; 
			case Tp_03_02_2022Package.ULTRASONIC_SENSOR:
				sequence_UltrasonicSensor(context, (UltrasonicSensor) semanticObject); 
				return; 
			case Tp_03_02_2022Package.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case Tp_03_02_2022Package.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			case Tp_03_02_2022Package.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Actions returns Accelerate
	 *     Accelerate returns Accelerate
	 *     Statement returns Accelerate
	 *
	 * Constraint:
	 *     (moteur=[Moteur|FQN] speed=INT? duration=INT?)
	 */
	protected void sequence_Accelerate(ISerializationContext context, Accelerate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Addition
	 *     Expression returns Addition
	 *     Addition returns Addition
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColorRef returns ColorRef
	 *
	 * Constraint:
	 *     referencetocolor=[ReferenceToColor|ID]
	 */
	protected void sequence_ColorRef(ISerializationContext context, ColorRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.COLOR_REF__REFERENCETOCOLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.COLOR_REF__REFERENCETOCOLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorRefAccess().getReferencetocolorReferenceToColorIDTerminalRuleCall_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.COLOR_REF__REFERENCETOCOLOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns ColorSensor
	 *     ColorSensor returns ColorSensor
	 *
	 * Constraint:
	 *     (name=ID sensorPort=INT)
	 */
	protected void sequence_ColorSensor(ISerializationContext context, ColorSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getColorSensorAccess().getSensorPortINTTerminalRuleCall_2_1_0(), semanticObject.getSensorPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Comparison
	 *     Expression returns Comparison
	 *     Comparison_Impl returns Comparison
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Comparison_Impl(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparison_ImplAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparison_ImplAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Division
	 *     Expression returns Division
	 *     Division returns Division
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Division(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivisionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivisionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ElseMotor
	 *     ConditionMotor returns ElseMotor
	 *     ElseMotor returns ElseMotor
	 *
	 * Constraint:
	 *     statement+=Statement*
	 */
	protected void sequence_ElseMotor(ISerializationContext context, ElseMotor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanOperationsOnMotors returns EqualM
	 *     EqualM returns EqualM
	 *
	 * Constraint:
	 *     (leftC=ColorRef rightC=VariableRef)
	 */
	protected void sequence_EqualM(ISerializationContext context, EqualM semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__LEFT_C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__LEFT_C));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__RIGHT_C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__RIGHT_C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualMAccess().getLeftCColorRefParserRuleCall_1_0(), semanticObject.getLeftC());
		feeder.accept(grammarAccess.getEqualMAccess().getRightCVariableRefParserRuleCall_3_0(), semanticObject.getRightC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Equal
	 *     Expression returns Equal
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (expression=Expression statement+=Statement*)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns GPSSensor
	 *     GPSSensor returns GPSSensor
	 *
	 * Constraint:
	 *     (name=ID sensorPort=INT)
	 */
	protected void sequence_GPSSensor(ISerializationContext context, GPSSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGPSSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGPSSensorAccess().getSensorPortINTTerminalRuleCall_2_1_0(), semanticObject.getSensorPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GreaterThan
	 *     Expression returns GreaterThan
	 *     GreaterThan returns GreaterThan
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_GreaterThan(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterThanAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterThanAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanOperationsOnMotors returns GreatherThanM
	 *     GreatherThanM returns GreatherThanM
	 *
	 * Constraint:
	 *     (leftC=ColorRef rightC=VariableRef)
	 */
	protected void sequence_GreatherThanM(ISerializationContext context, GreatherThanM semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__LEFT_C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__LEFT_C));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__RIGHT_C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BOOLEAN_OPERATIONS_ON_MOTORS__RIGHT_C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreatherThanMAccess().getLeftCColorRefParserRuleCall_1_0(), semanticObject.getLeftC());
		feeder.accept(grammarAccess.getGreatherThanMAccess().getRightCVariableRefParserRuleCall_3_0(), semanticObject.getRightC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns GyroSensor
	 *     GyroSensor returns GyroSensor
	 *
	 * Constraint:
	 *     (name=ID sensorPort=INT)
	 */
	protected void sequence_GyroSensor(ISerializationContext context, GyroSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGyroSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGyroSensorAccess().getSensorPortINTTerminalRuleCall_2_1_0(), semanticObject.getSensorPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfCondition
	 *     Conditionnal returns IfCondition
	 *     IfCondition returns IfCondition
	 *
	 * Constraint:
	 *     (expression=Expression statement+=Statement* statement+=Statement*)
	 */
	protected void sequence_IfCondition(ISerializationContext context, IfCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfMotor
	 *     ConditionMotor returns IfMotor
	 *     IfMotor returns IfMotor
	 *
	 * Constraint:
	 *     (boolM=BooleanOperationsOnMotors statement+=Statement* elsemotor+=ElseMotor*)
	 */
	protected void sequence_IfMotor(ISerializationContext context, IfMotor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns InfraredSensor
	 *     InfraredSensor returns InfraredSensor
	 *
	 * Constraint:
	 *     (name=ID sensorPort=INT)
	 */
	protected void sequence_InfraredSensor(ISerializationContext context, InfraredSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfraredSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInfraredSensorAccess().getSensorPortINTTerminalRuleCall_2_1_0(), semanticObject.getSensorPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns IntensitySensor
	 *     IntensitySensor returns IntensitySensor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_IntensitySensor(ISerializationContext context, IntensitySensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntensitySensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Moteur returns LeftMotor
	 *     LeftMotor returns LeftMotor
	 *
	 * Constraint:
	 *     (name=ID initialSpeed=INT? port=MOTORID)
	 */
	protected void sequence_LeftMotor(ISerializationContext context, LeftMotor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rotate returns LeftRotation
	 *     LeftRotation returns LeftRotation
	 *     Statement returns LeftRotation
	 *
	 * Constraint:
	 *     (leftmotor=[LeftMotor|FQN] rightmotor=[RightMotor|FQN] angle=INT? duration=INT?)
	 */
	protected void sequence_LeftRotation(ISerializationContext context, LeftRotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns LightSensor
	 *     LightSensor returns LightSensor
	 *
	 * Constraint:
	 *     (name=ID sensorPort=INT)
	 */
	protected void sequence_LightSensor(ISerializationContext context, LightSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLightSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLightSensorAccess().getSensorPortINTTerminalRuleCall_2_1_0(), semanticObject.getSensorPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LowerThan
	 *     Expression returns LowerThan
	 *     LowerThan returns LowerThan
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_LowerThan(ISerializationContext context, LowerThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerThanAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLowerThanAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MoveLeft returns MoveLeft
	 *     Statement returns MoveLeft
	 *
	 * Constraint:
	 *     (leftmotor=[LeftMotor|FQN] rightmotor=[RightMotor|FQN] speed=INT)
	 */
	protected void sequence_MoveLeft(ISerializationContext context, MoveLeft semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__SPEED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveLeftAccess().getLeftmotorLeftMotorFQNParserRuleCall_2_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR, false));
		feeder.accept(grammarAccess.getMoveLeftAccess().getRightmotorRightMotorFQNParserRuleCall_4_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR, false));
		feeder.accept(grammarAccess.getMoveLeftAccess().getSpeedINTTerminalRuleCall_6_0(), semanticObject.getSpeed());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Move returns Move
	 *     Statement returns Move
	 *
	 * Constraint:
	 *     (leftmotor=[LeftMotor|FQN] rightmotor=[RightMotor|FQN] speed=INT)
	 */
	protected void sequence_Move(ISerializationContext context, Move semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__SPEED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveAccess().getLeftmotorLeftMotorFQNParserRuleCall_2_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR, false));
		feeder.accept(grammarAccess.getMoveAccess().getRightmotorRightMotorFQNParserRuleCall_4_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR, false));
		feeder.accept(grammarAccess.getMoveAccess().getSpeedINTTerminalRuleCall_6_0(), semanticObject.getSpeed());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Multiplication
	 *     Expression returns Multiplication
	 *     Multiplication returns Multiplication
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns OnForRotation
	 *     OnForRotation returns OnForRotation
	 *     Statement returns OnForRotation
	 *
	 * Constraint:
	 *     (moteur=[Moteur|FQN] speed=INT angle=INT)
	 */
	protected void sequence_OnForRotation(ISerializationContext context, OnForRotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__MOTEUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__MOTEUR));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__SPEED));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnForRotationAccess().getMoteurMoteurFQNParserRuleCall_2_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.ACTIONS__MOTEUR, false));
		feeder.accept(grammarAccess.getOnForRotationAccess().getSpeedINTTerminalRuleCall_4_0(), semanticObject.getSpeed());
		feeder.accept(grammarAccess.getOnForRotationAccess().getAngleINTTerminalRuleCall_6_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns PositionSensor
	 *     PositionSensor returns PositionSensor
	 *
	 * Constraint:
	 *     (name=ID sensorPort=INT?)
	 */
	protected void sequence_PositionSensor(ISerializationContext context, PositionSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=ID robot+=Robot* variable+=Variable* referencetocolor+=ReferenceToColor* statement+=Statement*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceToColor returns ReferenceToColor
	 *
	 * Constraint:
	 *     (name=ID colorsensor=[ColorSensor|FQN])
	 */
	protected void sequence_ReferenceToColor(ISerializationContext context, ReferenceToColor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.REFERENCE_TO_COLOR__COLORSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.REFERENCE_TO_COLOR__COLORSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceToColorAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReferenceToColorAccess().getColorsensorColorSensorFQNParserRuleCall_5_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.REFERENCE_TO_COLOR__COLORSENSOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Moteur returns RightMotor
	 *     RightMotor returns RightMotor
	 *
	 * Constraint:
	 *     (name=ID initialSpeed=INT? port=MOTORID)
	 */
	protected void sequence_RightMotor(ISerializationContext context, RightMotor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rotate returns RightRotation
	 *     RightRotation returns RightRotation
	 *     Statement returns RightRotation
	 *
	 * Constraint:
	 *     (leftmotor=[LeftMotor|FQN] rightmotor=[RightMotor|FQN] angle=INT? duration=INT?)
	 */
	protected void sequence_RightRotation(ISerializationContext context, RightRotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (name=ID moteur+=Moteur* sensor+=Sensor*)
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetThank returns SetThank
	 *     Statement returns SetThank
	 *
	 * Constraint:
	 *     (leftmotor=[LeftMotor|FQN] rightmotor=[RightMotor|FQN])
	 */
	protected void sequence_SetThank(ISerializationContext context, SetThank semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetThankAccess().getLeftmotorLeftMotorFQNParserRuleCall_2_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__LEFTMOTOR, false));
		feeder.accept(grammarAccess.getSetThankAccess().getRightmotorRightMotorFQNParserRuleCall_4_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.MULTIPLE_MOTOR_ACTIONS__RIGHTMOTOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *     Statement_Impl returns Statement
	 *
	 * Constraint:
	 *     {Statement}
	 */
	protected void sequence_Statement_Impl(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns Stop
	 *     Stop returns Stop
	 *     Statement returns Stop
	 *
	 * Constraint:
	 *     moteur=[Moteur|FQN]
	 */
	protected void sequence_Stop(ISerializationContext context, Stop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__MOTEUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.ACTIONS__MOTEUR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStopAccess().getMoteurMoteurFQNParserRuleCall_2_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.ACTIONS__MOTEUR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Substraction
	 *     Expression returns Substraction
	 *     Substraction returns Substraction
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Substraction(ISerializationContext context, Substraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstractionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubstractionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns TurnOn
	 *     TurnOn returns TurnOn
	 *     Statement returns TurnOn
	 *
	 * Constraint:
	 *     (moteur=[Moteur|FQN] speed=INT?)
	 */
	protected void sequence_TurnOn(ISerializationContext context, TurnOn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns UltrasonicSensor
	 *     UltrasonicSensor returns UltrasonicSensor
	 *
	 * Constraint:
	 *     (name=ID sensorPort=INT)
	 */
	protected void sequence_UltrasonicSensor(ISerializationContext context, UltrasonicSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.SENSOR__SENSOR_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUltrasonicSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUltrasonicSensorAccess().getSensorPortINTTerminalRuleCall_2_1_0(), semanticObject.getSensorPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableRef
	 *     Reference returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Tp_03_02_2022Package.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Tp_03_02_2022Package.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(Tp_03_02_2022Package.Literals.VARIABLE_REF__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (isConst?='const'? name=ID initialValue=INT?)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (expression=Expression statement+=Statement*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
