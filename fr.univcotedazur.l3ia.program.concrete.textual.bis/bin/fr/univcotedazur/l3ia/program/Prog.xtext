// automatically generated by Xtext
grammar fr.univcotedazur.l3ia.program.Prog with org.eclipse.xtext.common.Terminals

import "http://www.example.org/Tp_03_02_2022"  
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Program returns Program:
	{Program}
	'Program' 
	  name = ID
	    (robot+=Robot)* 
		(variable+=Variable)*
		(referencetocolor+=ReferenceToColor)*
		(statement+=Statement)*
		
		
		//(statement+=Statement(';'statement+=Statement)*)?
		//'statement' '{'
		// statement+=Statement ( "," 
		// '}' )?
;

ReferenceToColor returns ReferenceToColor:
	{ReferenceToColor}
	
	'ref' name =ID 
	'='
	'('
	(colorsensor = [ColorSensor | FQN])
	'color_name'
	')'
	
	;

Robot returns Robot: 
	'Robot'
	name = ID
	'{'
	(moteur+=Moteur)*
	(sensor+=Sensor)*
	'}'
;

Sensor returns Sensor:
	IntensitySensor | ColorSensor | PositionSensor | InfraredSensor | GyroSensor | GPSSensor | LightSensor | UltrasonicSensor 
;

Actions returns Actions:
	Stop | OnForRotation | Accelerate | TurnOn
;

Moteur returns Moteur:
	LeftMotor |RightMotor 
;


TurnOn returns TurnOn:
	'turnOn' 
	'('
	 moteur =[Moteur | FQN] //STRING
	 (',' ('speed' '=')? speed = INT)?
	')'
;

Accelerate returns Accelerate:
	'accelerate'
	'('
	moteur = [Moteur | FQN] //STRING
	(',' ('speed' '=')? speed = INT)?
	(',' ('seconds' '=')? duration=INT)?
	')'
;

Rotate returns Rotate:
	LeftRotation | RightRotation
;

LeftRotation returns LeftRotation:
	'turnLeft'
	'('
	leftmotor = [LeftMotor | FQN]
	','
	rightmotor = [RightMotor | FQN]
	(',' ('angle' '=')? angle = INT)?
	(',' ('seconds' '=')? duration=INT)?
	')'
;

RightRotation returns RightRotation:
	'turnRight'
	'('
	leftmotor = [LeftMotor | FQN]
	','
	rightmotor = [RightMotor | FQN]
	(',' ('angle' '=')? angle = INT)?
	(',' ('seconds' '=')? duration=INT)?
	')'
;

/*Rotate returns Rotate:
	'rotate'
	'('
	moteur = [Moteur | FQN]
	(',' ('angle' '=')? angle = INT)?
	')'
;"""*/

FQN: //Fully Qualified Name
	ID('.'ID)*
;

OnForRotation returns OnForRotation:
	'onForRotation'
	'('
	moteur =[Moteur | FQN] //STRING
	','
	speed=INT
	','
	angle=INT
	')'
;

Stop returns Stop:
	'stop' 
	'('
	 moteur =[Moteur | FQN] //STRING
	')'
;



LeftMotor returns LeftMotor:
	'leftMotor'
	name = ID
	
	('=' initialSpeed = INT)?
	('on' (port = MOTORID)) 
	
;

RightMotor returns RightMotor:
	'rightMotor'
	name = ID
	
	('=' initialSpeed = INT)?
	('on' (port = MOTORID)) 
	
;

	terminal MOTORID: ('A'..'H');


InfraredSensor returns InfraredSensor:
	'infraredSensor'
	name = ID
	('on' (sensorPort = INT))
;

GyroSensor returns GyroSensor:
	'gyroSensor'
	name = ID
	('on' (sensorPort = INT))
;

GPSSensor returns GPSSensor:
	'gpsSensor'
	name = ID
	('on' (sensorPort = INT))
;

LightSensor returns LightSensor:
	'lightSensor'
	name=ID
	('on' (sensorPort = INT))
;

UltrasonicSensor returns UltrasonicSensor:
	'ultrasonicSensor'
	name=ID
	('on' (sensorPort = INT))
;

ColorSensor returns ColorSensor:
	'colorSensor'
	name = ID
	('on' (sensorPort = INT))
	 
;

PositionSensor returns PositionSensor:
	'positionSensor'
	name = ID
	('on' (sensorPort = INT))? 
	
;

IntensitySensor returns IntensitySensor:
	'intensitySensor'
	name = ID
;

Move returns Move:
	'move'
	'('
    leftmotor = [LeftMotor | FQN]
    ','
	rightmotor = [RightMotor | FQN]
	','
	speed = INT
	')'
;

MoveLeft returns MoveLeft:
	'moveLeft'
	'('
	leftmotor = [LeftMotor | FQN]
    ','
	rightmotor = [RightMotor | FQN]
	','
	speed = INT
	')'
;

SetThank returns SetThank:
	'setThank'
	'('
	leftmotor = [LeftMotor | FQN]
    ','
	rightmotor = [RightMotor | FQN]
	')'
;
//ColorRef | 

Statement returns Statement:
	ConditionMotor | IfMotor | IfCondition | Statement_Impl | Accelerate| Stop| OnForRotation | Move | MoveLeft | SetThank| LeftRotation | RightRotation | WhileLoop | Assignment | Comparison_Impl | Substraction | GreaterThan | LowerThan | Equal | ForLoop | Addition | Multiplication | Division | Actions;

//| VariableRef 

ConditionMotor returns ConditionMotor:
	IfMotor | ElseMotor
;

BooleanOperationsOnMotors returns BooleanOperationsOnMotors:
	EqualM | GreatherThanM
;

GreatherThanM returns GreatherThanM:
	{GreatherThanM}
	leftC=ColorRef
	'>'
	rightC=VariableRef
;
EqualM returns EqualM:
	{EqualM}
	
	leftC=ColorRef
	'=='
	rightC=VariableRef
;


IfMotor returns IfMotor:
	{IfMotor}
	'ifM'
	'('boolM=BooleanOperationsOnMotors')'
	'{'
	(statement+=Statement)*
	'}'
	
	(elsemotor += ElseMotor)*
	
	
;

ElseMotor returns ElseMotor:
	{ElseMotor}
	('else'
	    '{'
	    (statement+=Statement)*
	    '}')
;

Expression returns Expression:
	Reference | Assignment | Comparison_Impl | Substraction | GreaterThan | LowerThan | Equal | Addition | Multiplication | Division;

Reference returns Reference:
	 VariableRef
;

//ColorRef |

ColorRef returns ColorRef:

		 referencetocolor=[ReferenceToColor|ID]
	;

Conditionnal returns Conditionnal:
	IfCondition
;

IfCondition returns IfCondition:
	//'WhileLoop'
	'if'
	
	
		//'expression' 
		'('expression=Expression')'
		//('and' expression = Expression )?
		'{'
			(statement+=Statement)*
	    '}'
	    ('else'
	    '{'
	    (statement+=Statement)*
	    '}')?
;

Variable returns Variable:
	{Variable}
	(isConst?='const')?
	'Variable' name =ID 
	'='
	(initialValue = INT)?
	;

//enum EInt:
	
//;


Statement_Impl returns Statement:
	{Statement}
	'Statement'
	;
//EInt returns ecore::EInt:
	
	

	
	
//;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

WhileLoop returns WhileLoop:
	//'WhileLoop'
	'while'
	
		//'expression' 
		expression=Expression
		'{'
			(statement+=Statement)*
	    '}'
	;

VariableRef returns VariableRef:
	//'VariableRef'
	//'{'
		//'variable'
		 variable=[Variable|ID]
	//'}'
	;

Assignment returns Assignment:
	//'Assignment'
	//'{'
		
		//'left' 
		'('
		left=Expression
		
		':='
		//'right' 
		
		right=Expression
		')'
	//'}'
	;

Comparison_Impl returns Comparison:
	//'Comparison'
	//'{'
		//'left' 
		'('
		left=Expression
		//'right' 
		right=Expression
		')'
	//'}'
	;

Substraction returns Substraction:
	//'Substraction'
	//'{'
		//'left'
		'(' 
		left=Expression
		//'right' 
		'-'
		right=Expression
		')'
	//'}'
	;

GreaterThan returns GreaterThan:
	//'GreaterThan'
	//'{'
		//'left'
		'(' 
		left=Expression
		'>'
		//'right' 
		right=Expression
		')'
	//'}'
	;

LowerThan returns LowerThan:
	//'LowerThan'
	//'{'
		//'left' 
		'('
		left=Expression
		'<'
		//'right' 
		right=Expression
		')'
	//'}'
	;

Equal returns Equal:
	//'Equal'
	//'{'
	//	'left' 
	'('
		left=Expression
		'=='
		//'right' 
		right=Expression
	')'
	;

ForLoop returns ForLoop:
	//'ForLoop'
	//'{'
		//'expression' 
		'for'
		expression=Expression 
		'{'
			(statement+=Statement)* 
		'}'
		
	//'}'
	;

Addition returns Addition:
	//'Addition'
	//'{'
		//'left' 
		'('
		left=Expression
		'+'
		//'right' 
		
		right=Expression
		')'
	//'}'
	;

Multiplication returns Multiplication:
	//'Multiplication'
	//'{'
		'('
		//'left' 
		left=Expression
		'*'
		//'right' 
		right=Expression
		')'
	//'}'
	;

Division returns Division:
	//'Division'
	//'{'
		//'left' 
		'('
		left=Expression
		'/'
		//'right' 
		right=Expression
		')'
	//'}'
	;
